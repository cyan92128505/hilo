// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/gin-contrib/pprof"
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
	"go.uber.org/zap"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"hilo-api/internal/presentation/restful"
	"hilo-api/pkg/config"
	"hilo-api/pkg/jwt"
	"hilo-api/pkg/logger"
	restful2 "hilo-api/pkg/restful"
	"net/http"
)

// Injectors from wire.go:

func RestfulRunner() (Empty, func(), error) {
	set, err := config.NewSet()
	if err != nil {
		return Empty{}, nil, err
	}
	core := config.NewCore(set)
	zapLogger, err := logger.NewZap(core)
	if err != nil {
		return Empty{}, nil, err
	}
	server := config.NewServer(set)
	configJWT := config.NewJWT(set)
	es256JWT, err := jwt.NewES256JWTFromOptions(configJWT)
	if err != nil {
		return Empty{}, nil, err
	}
	apiGuardValidator := restful.NewAPIGuardValidator(es256JWT)
	jwtGuarder := restful2.NewJWTGuarder(apiGuardValidator)
	engine, err := restful2.NewGin(zapLogger, server, jwtGuarder)
	if err != nil {
		return Empty{}, nil, err
	}
	commonHandler := _wireCommonHandlerValue
	handlerSet := restful.HandlerSet{}
	empty, cleanup, err := RunRestfulServer(zapLogger, set, engine, commonHandler, handlerSet)
	if err != nil {
		return Empty{}, nil, err
	}
	return empty, func() {
		cleanup()
	}, nil
}

var (
	_wireCommonHandlerValue = restful2.CommonHandler{
		Error404:   restful2.Error404Set,
		QuickReply: restful2.QuickReplySet,
		PromHTTP:   restful2.NewPromHTTPSet,
	}
)

// wire.go:

func ctx() context.Context {
	return context.Background()
}

var ctxSet = wire.NewSet(ctx)

var LoggerSet = wire.NewSet(logger.NewZap)

type Empty struct{}

func RunRestfulServer(logger2 *zap.Logger, coreOptions config.Set, route *gin.Engine, commonHandler restful2.CommonHandler, handlers restful.HandlerSet) (Empty, func(), error) {
	restful.AddRoutes(route, commonHandler, handlers)
	if !coreOptions.Core.IsReleaseMode {
		pprof.Register(route)
	}

	h2s := &http2.Server{}

	httpServer := &http.Server{
		Addr:    fmt.Sprintf(":%s", coreOptions.Server.Port),
		Handler: h2c.NewHandler(route, h2s),
	}

	go func(s *http.Server) {
		logger2.
			Info("start restful server", zap.String("system", coreOptions.Core.SystemName), zap.String("port", coreOptions.Server.Port))
		if err := s.ListenAndServe(); err != nil {
			logger2.
				Warn("restful server error or closed", zap.String("system", coreOptions.Core.SystemName), zap.Error(err))
		}
	}(httpServer)
	return Empty{}, func() {
		ctx2, cancel := context.WithTimeout(context.Background(), coreOptions.Server.ServerTimeout)
		defer cancel()
		if err := httpServer.Shutdown(ctx2); err != nil {
			logger2.
				Warn("restful server Failed to Shutdown", zap.String("system", coreOptions.Core.SystemName), zap.Error(err))
		}
	}, nil
}
